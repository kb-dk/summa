/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package dk.statsbiblioteket.summa.ingest.split;

import dk.statsbiblioteket.summa.common.Record;
import dk.statsbiblioteket.summa.common.configuration.Configuration;
import dk.statsbiblioteket.summa.common.filter.Payload;
import dk.statsbiblioteket.summa.common.util.RecordUtil;
import dk.statsbiblioteket.util.qa.QAInfo;
import dk.statsbiblioteket.util.xml.XMLUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.events.XMLEvent;
import java.io.StringWriter;
import java.text.ParseException;
import java.util.Locale;
import java.util.regex.Pattern;

/**
 * A modified MARC21Slim-like parser that steps through MARC records and sends
 * events when leader, controlfield, datafield and subfields are encountered.
 * The parser also handles the logic of adding produced Records to the queue.
 * A streaming parser is used as performance is prioritized over clarity (the
 * streaming parser has less GC overhead than a full DOM build).
 * </p><p>
 * Extracting concrete information and constructing Summa Records is left to
 * classes extending this parser. Such classes only need to match the
 * constructor and implement the abstract methods. Implementations should use
 * {@link #expandID} before adding IDs to a Record..
 * </p><p>
 * The overall structure of a MARC-dump is
 * {@code
<collection xmlns="http://www.loc.gov/MARC21/slim">
<record>
<leader>...</leader>
<datafield tag="..." ind1="..." ind2="...">
<subfield code="...">...</subfield>+
</datafield>*
</record>*
</collection>
} where * indicates multiple and + at least one occurence of the element.
 * </p><p>
 * Important: This parser does not handle controlfields natively.
 * Controlfields are passed along unprocessed. If any action should be taken
 * upon encountering a controlfield, the method {@link #setControlField} should
 * be implemented.
 */
@QAInfo(level = QAInfo.Level.NORMAL,
        state = QAInfo.State.QA_NEEDED,
        author = "te",
        comment = "The parser should be extended for proper handling of control fields")
public abstract class MARCParser extends ThreadedStreamParser {
    private static Log log = LogFactory.getLog(MARCParser.class);

    /**
     * The base for the Records generated by the parser.
     * </p><p>
     * This property is mandatory.
     */
    public static final String CONF_BASE = "summa.ingest.marcparser.base";

    /**
     * The prefix to prepend to ids extracted from the MARC records before
     * generating a Summa Record.
     * </p><p>
     * This property is optional. Default is "".
     */
    public static final String CONF_ID_PREFIX = "summa.ingest.marcparser.id.prefix";
    public static final String DEFAULT_ID_PREFIX = "";

    /**
     * The prefix to append to ids extracted from the MARC records before
     * generating a Summa Record.
     * </p><p>
     * This property is optional. Default is "".
     */
    public static final String CONF_ID_POSTFIX = "summa.ingest.marcparser.id.postfix";
    public static final String DEFAULT_ID_POSTFIX = "";

    public static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";

    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    public static final String MARC_TAG_RECORD = "record";

    public static final String MARC_TAG_LEADER = "leader";

    public static final String MARC_TAG_DATAFIELD = "datafield";
    public static final String MARC_TAG_DATAFIELD_ATTRIBUTE_TAG = "tag";
    public static final String MARC_TAG_DATAFIELD_ATTRIBUTE_IND1 = "ind1";
    public static final String MARC_TAG_DATAFIELD_ATTRIBUTE_IND2 = "ind2";
    public static final String MARC_TAG_SUBFIELD = "subfield";
    public static final String MARC_TAG_SUBFIELD_ATTRIBUTE_CODE = "code";

    public static final String MARC_TAG_CONTROLFIELD = "controlfield";
    public static final String MARC_TAG_CONTROLFIELD_ATTRIBUTE_TAG = "tag";

    private XMLInputFactory inputFactory;

    /**
     * The base for Records produced by implementations of MARCParser.
     */
    protected String base;
    /**
     * Prepended to the extracted id. Used by subclasses.
     */
    private String id_prefix = DEFAULT_ID_PREFIX;
    /**
     * Appended to the extracted id. Used by subclasses.
     */
    private String id_postfix = DEFAULT_ID_POSTFIX;

    public MARCParser(Configuration conf) {
        super(conf);
        inputFactory = XMLInputFactory.newInstance();
        // There should be no CData in the MARC XML
//        inputFactory.setProperty("report-cdata-event", Boolean.TRUE);
        inputFactory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);
        // No resolving of external DTDs
        inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);
        base = conf.getString(CONF_BASE, null);
        if (base == null) {
            throw new ConfigurationException(String.format(
                    Locale.ROOT, "A base must be specified with key %s", CONF_BASE));
        }
        id_prefix = conf.getString(CONF_ID_PREFIX, id_prefix);
        id_postfix = conf.getString(CONF_ID_POSTFIX, id_postfix);
        log.debug(String.format(Locale.ROOT, "Created MARC parser with base '%s', id prefix '%s', id postfix '%s'",
                                base, id_prefix, id_postfix));
    }

    // TODO: Pass this as arguments instead of using a field
    protected Payload source = null;

    // http://java.sun.com/javaee/5/docs/tutorial/doc/bnbfl.html
    @Override
    protected void protectedRun(Payload source) throws Exception {
        this.source = source;
        XMLStreamReader reader = inputFactory.createXMLStreamReader(RecordUtil.getStream(source), "utf-8");
        // Positioned at startDocument
        int eventType = reader.getEventType();
        if (eventType != XMLEvent.START_DOCUMENT) {
            throw new ParseException(String.format(Locale.ROOT, "The first element should be start, it was %s",
                                                   XMLUtil.eventID2String(eventType)), 0);
        }

        while (running && reader.hasNext()) {
            eventType = reader.next();
            //noinspection DuplicateStringLiteralInspection
            if (eventType == XMLEvent.START_ELEMENT && MARC_TAG_RECORD.equals(reader.getLocalName())) {
                processInRecord(reader);
            }
        }
    }

    /**
     * Collect record information and ultimately build a Record and add it to
     * the queue before returning.
     * @param reader a reader positioned at the start of a record.
     * @throws XMLStreamException   if a parse error occured.
     * @throws InterruptedException if the process was interrupted while adding
     *                              to the queue.
     */
    private void processInRecord(XMLStreamReader reader) throws XMLStreamException, InterruptedException {
        initializeNewParse();
        StringWriter content = new StringWriter(2000); // Full MARC content

        boolean encounteredUnexpectedStart = false;
        // TODO: Add XML-declaration and namespace
        content.append(XML_HEADER + "\n");
        content.append(beginTagToString(reader, true));
        while (running && reader.hasNext()) {
            int eventType = reader.next();

            switch(eventType) {
                case XMLEvent.START_ELEMENT :
                    if (MARC_TAG_DATAFIELD.equals(reader.getLocalName())) {
                        content.append(beginTagToString(reader));
                        processDataField(reader, content);
                    } else if (MARC_TAG_CONTROLFIELD.equals(reader.getLocalName())) {
                        processControlField(reader, content);
                    } else if (MARC_TAG_LEADER.equals(reader.getLocalName())) {
                        content.append(beginTagToString(reader));
                        processLeader(reader, content);
                    } else {
                        content.append(beginTagToString(reader));
                        if (!encounteredUnexpectedStart) {
                            encounteredUnexpectedStart = true;
                            log.warn(String.format(Locale.ROOT,
                                    "Unexpected start-tag '%s' while parsing MARC for %s. This is the first time this"
                                    + " has been encountered. Further encounters will be logged on debug",
                                    reader.getLocalName(), source));
                        } else {
                            log.debug("Unexpected start-tag '" + reader.getLocalName()
                                      + "' while parsing MARC for " + source);
                        }
                    }
                    break;
                case XMLEvent.END_ELEMENT :
                    content.append(endTagToString(reader));
                    if (MARC_TAG_RECORD.equals(reader.getLocalName())) {
                        if (running) {
                            Record record = makeRecord(content.toString());
                            if (record != null) {
                                addToQueue(record);
                            }
                        }
                        return;
                    }
                    log.warn(String.format(Locale.ROOT, "Unexpected end-tag '%s' while parsing MARC for %s",
                                           reader.getLocalName(), source));
                    break;
                case XMLEvent.CHARACTERS :
                    if (!isBlank(reader.getText())) {
                        log.warn(String.format(Locale.ROOT, "Unexpected text '%s' while parsing MARC in %s",
                                               reader.getText(), source));
                    }
                    // TODO: Test for "foo &lt;bar"
                    content.append(XMLUtil.encode(reader.getText()));
                    break;
                case XMLEvent.COMMENT:
                    log.trace("Encountered comment");
                    content.append("<!--").append(reader.getText()).append("-->");
                    break;
                default:
                    log.warn(String.format(Locale.ROOT, "Unexpended event %s while processing %s",
                                           XMLUtil.eventID2String(eventType),
                                           source));
            }
        }
        if (!running) {
            log.debug("processInRecord stopped as running was false");
        }
    }

    private static final Pattern BLANKS = Pattern.compile("( |\n|\t)*");
    /**
     * Test whether text is made up of ignorable blanks, which translates to
     * line-breaks, space and tab.
     * @param text the String to analyze for blanks.
     * @return true if the text consists solely of blanks.
     */
    protected static boolean isBlank(String text) {
        return BLANKS.matcher(text).matches();
    }

    /**
     * Process the leader in a MARC record, such as
     * {@code <leader>.....cmm  22.....0  45032</leader>}.
     * @param reader  the reader, positioned at the start-tag for a leader.
     * @param content the XML content up till this point, including <leader>.
     * @throws XMLStreamException   if a parse error occured.
     * @throws InterruptedException if the process was interrupted while adding
     *                              to the queue.
     */
    private void processLeader(XMLStreamReader reader, StringWriter content) throws XMLStreamException {
        log.trace("Reached leader start-tag");
        String leaderContent = "";
        while (running && reader.hasNext()) {
            int eventType = reader.next();

            switch(eventType) {
                case XMLEvent.START_ELEMENT :
                    content.append(beginTagToString(reader));
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT,
                            "processLeader: Reached unexpected start-tag <%s> for %s. Expected none",
                            reader.getLocalName(), source));
                    break;
                case XMLEvent.END_ELEMENT :
                    content.append(endTagToString(reader));
                    if (MARC_TAG_LEADER.equals(reader.getLocalName())) {
                        if ("".equals(leaderContent)) {
                            log.debug("No leader content for " + source);
                        }
                        setLeader(leaderContent);
                        return;
                    }
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT, "processLeader: Reached unexpected end-tag </%s> for %s. Expected </%s>",
                                           reader.getLocalName(), source, MARC_TAG_LEADER));
                    break;
                case XMLEvent.CHARACTERS :
                    // TODO: Test for "foo &lt;bar"
                    leaderContent = reader.getText();
                    content.append(XMLUtil.encode(reader.getText()));
                    break;
                default:
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT, "processLeader: Unexpended event %s while processing %s",
                                           XMLUtil.eventID2String(eventType),
                                           source));
            }
        }
    }

    /**
     * Process datafield-elements in a MARC record, such as {@code
    <datafield tag="..." ind1="..." ind2="...">
    <subfield code="...">...</subfield>+
    </datafield>
    }.
     * @param reader  the reader, positioned at the start-tag for a datafield.
     * @param content the XML content up till this point, including
     *                {@code <datafield ...>}.
     * @throws XMLStreamException   if a parse error occured.
     */
    protected void processDataField(
            XMLStreamReader reader, StringWriter content)
            throws XMLStreamException {
        log.trace("Reached datafield start-tag");
        String tag = null;
        String ind1 = null;
        String ind2 = null;
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            if (reader.getAttributeLocalName(i).equals(MARC_TAG_DATAFIELD_ATTRIBUTE_TAG)) {
                tag = reader.getAttributeValue(i);
            } else if (reader.getAttributeLocalName(i).equals(MARC_TAG_DATAFIELD_ATTRIBUTE_IND1)) {
                ind1 = reader.getAttributeValue(i);
            } else if (reader.getAttributeLocalName(i).equals(MARC_TAG_DATAFIELD_ATTRIBUTE_IND2)) {
                ind2 = reader.getAttributeValue(i);
            } else {
                if (log.isTraceEnabled()) {
                    log.trace(String.format(Locale.ROOT,
                            "processDatafield: Unexpected attribute %s with value '%s' for tag %s",
                            reader.getAttributeLocalName(i),
                            reader.getAttributeValue(i), MARC_TAG_DATAFIELD));
                }
            }
        }
        beginDataField(tag, ind1, ind2);

        while (running && reader.hasNext()) {
            int eventType = reader.next();

            switch(eventType) {
                case XMLEvent.START_ELEMENT :
                    if (MARC_TAG_SUBFIELD.equals(reader.getLocalName())) {
                        processSubField(reader, content, tag, ind1, ind2);
                    } else {
                        content.append(beginTagToString(reader));
                        log.warn(String.format(Locale.ROOT,
                                "processDataField: Reached unexpected start-tag <%s> for %s. Expected %s",
                                reader.getLocalName(), source, MARC_TAG_SUBFIELD));
                    }
                    break;
                case XMLEvent.END_ELEMENT :
                    content.append(endTagToString(reader));
                    if (MARC_TAG_DATAFIELD.equals(reader.getLocalName())) {
                        endDataField(tag);
                        return;
                    }
                    log.warn(String.format(Locale.ROOT,
                            "processDataField: Reached unexpected end-tag </%s> for %s. Expected </%s>",
                            reader.getLocalName(), source, MARC_TAG_DATAFIELD));
                    break;
                case XMLEvent.CHARACTERS :
                    if (!isBlank(reader.getText())) {
                        log.warn(String.format(Locale.ROOT,
                                "processDatafield: Unexpected text '%s' while parsing MARC for %s",
                                reader.getText(), source));
                    }
                    content.append(XMLUtil.encode(reader.getText()));
                    break;
                default:
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT,
                            "processDataField: Unexpended event %s while processing %s",
                            XMLUtil.eventID2String(eventType), source));
            }
        }
    }

    protected void processSubField(XMLStreamReader reader, StringWriter content, String tag, String ind1,
                                   String ind2) throws XMLStreamException {
        log.trace("Reached subfield start-tag");

        String code = null;
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            if (reader.getAttributeLocalName(i).equals(
                    MARC_TAG_SUBFIELD_ATTRIBUTE_CODE)) {
                code = reader.getAttributeValue(i);
            } else {
                log.warn(String.format(Locale.ROOT,
                        "processSubfield: Unexpected attribute %s with value '%s' for tag %s",
                        reader.getAttributeLocalName(i), reader.getAttributeValue(i), MARC_TAG_SUBFIELD));
            }
        }
        content.append(beginSubFieldTagToString(reader, tag, ind1, ind2, code));

        String subfieldcontent = "";
        while (running && reader.hasNext()) {
            int eventType = reader.next();

            switch(eventType) {
                case XMLEvent.START_ELEMENT :
                    content.append(beginTagToString(reader));
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT,
                            "processSubField: Reached unexpected start-tag <%s> for %s. Expected none",
                            reader.getLocalName(), source));
                    break;
                case XMLEvent.END_ELEMENT :
                    content.append(endTagToString(reader));
                    if (MARC_TAG_SUBFIELD.equals(reader.getLocalName())) {
                        if ("".equals(subfieldcontent) && log.isTraceEnabled()){
                            log.trace("No subfield content for " + source + " in datafield " + tag + ", subfield "
                                      + code);
                        }
                        setSubField(tag, ind1, ind2, code, subfieldcontent);
                        return;
                    }
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT,
                            "processsubField: Reached unexpected end-tag </%s> for %s. Expected </%s>",
                            reader.getLocalName(), source, MARC_TAG_SUBFIELD));
                    break;
                case XMLEvent.CHARACTERS :
                    subfieldcontent = reader.getText();
                    content.append(XMLUtil.encode(reader.getText()));
                    break;
                default:
                    //noinspection DuplicateStringLiteralInspection
                    log.warn(String.format(Locale.ROOT,
                            "processSubField: Unexpended event %s while processing %s",
                            XMLUtil.eventID2String(eventType), source));
            }
        }
    }

    /**
     * Process controlfield-elements in a MARC record, such as {@code
    <controlfield tag="...">...</controlfield>
    }.
     * @param reader  the reader positioned at the start-tag for a controlfield.
     * @param content the XML content up till this point, not including
     *                {@code <controlfield ...>}. Note that this is counter to
     *                processDataField, where the leading tag is added before
     *                the method call.
     * @throws XMLStreamException if a parse error occured.
     */
    protected void processControlField(XMLStreamReader reader, StringWriter content) throws XMLStreamException {
        String tag = null;
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            if (MARC_TAG_CONTROLFIELD_ATTRIBUTE_TAG.equals(reader.getAttributeLocalName(i))) {
                tag = reader.getAttributeValue(i);
            }
        }
        String fieldContent = reader.getElementText();

        if (tag == null && !noControlTagEncountered) {
            log.warn(String.format(Locale.ROOT,
                    "There is not attribute tag for the controlelement with content '%s'. Futher errors of this kind "
                    + "will be ignored", fieldContent));
            noControlTagEncountered = true;
        }

        String dumpContent = setControlField(tag, fieldContent);
        if (dumpContent != null) {
            content.append(dumpContent);
        }
    }
    private boolean noControlTagEncountered = true;

    /**
     * Initialize the MARC parser. This normally involves resetting all
     * attributes to their default states. This method is called at the start
     * of all record-elements.
     */
    protected abstract void initializeNewParse();

    /**
     * Set the leader for the record.
     * @param content the text in the leader-element.
     */
    protected abstract void setLeader(String content);

    /**
     * Marks the beginning of a datafield-element. Note that the method
     * {@link #setSubField} also contains tag, ind1 and ind2, so the
     * beginDataField-method might not need do anything, depending on
     * implementation.
     * @param tag  the id for the datafield.
     * @param ind1 the ind1-attribute for the datafield.
     * @param ind2 the ind2-attribute for the datafield.
     */
    protected abstract void beginDataField(
            String tag, String ind1, String ind2);

    /**
     * Set a subfield for a datafield. It is guaranteed that the subfields
     * for a datafield will follow after {@link #beginDataField} and before
     * {@link #endDataField}.
     * @param dataFieldTag  the id for the datafield.
     * @param dataFieldInd1 the ind-1 attribute for the datafield.
     * @param dataFieldInd2 the ind-2 attribute for the datafield.
     * @param subFieldCode  the code for the subfield.
     * @param subFieldContent the content of the subfield.
     */
    protected abstract void setSubField(String dataFieldTag, String dataFieldInd1,String dataFieldInd2,
                                        String subFieldCode, String subFieldContent);

    /**
     * Set a controlfield. Note that this method is optional. The default
     * implementation is to log a warning the first time the method is called.
     * @param tag     the tag for the controlfield.
     * @param content the content of the controlfield.
     * @return the output to write to the resulting XML stream. If null, the
     *         output is ignored.
     */
    protected String setControlField(String tag, String content) {
        if (!setControlFieldCalled) {
            log.info(String.format(Locale.ROOT,
                    "setControlField(%s, '%s') called, although there is no explicit handler for controlfields. "
                    + "The controlfield is written back directly. Subsequent calls will not be logged",
                    tag, content));
            setControlFieldCalled = true;
        }

        return String.format(Locale.ROOT, "<controlfield tag=\"%s\">%s</controlfield>\n", tag, content);
    }
    private boolean setControlFieldCalled = false;


    /**
     * Marks the end a datafield-element.
     * @param tag the id for the datafield.
     */
    protected abstract void endDataField(String tag);

    /**
     * Create a Record based on the received data, if possible.
     * @param xml the XML for the MARC record, ready for insertion in a Record.
     * @return a Record based on received data or null if a Record cannot be
     *         created.
     */
    protected abstract Record makeRecord(String xml);

    /**
     * Convert a begin-tag to String. Suitable for dumping while parsing.
     * @param reader a reader pointing to a begin-tag.
     * @return the begin-tag as text.
     */
    protected String beginTagToString(XMLStreamReader reader) {
        return beginTagToString(reader, false);
    }

    /**
     * Convert a begin-tag for a sub field to String. Suitable for dumping while
     * parsing. The base implementation of this method calls
     * {@link #beginTagToString(javax.xml.stream.XMLStreamReader, boolean)} and
     * is meant to be overridden if special processing is required.
     * @param reader a reader pointing to a begin-subfield-tag.
     * @param tag  the tag for the outer data field.
     * @param ind1 ind1 for the outer data field.
     * @param ind2 ind2 for the outer data field.
     * @param code the code for the sub field.
     * @return the begin-tag as text.
     */
    @SuppressWarnings({"UnusedDeclaration"})
    protected String beginSubFieldTagToString(XMLStreamReader reader, String tag, String ind1,
                                              String ind2, String code) {
        return beginTagToString(reader, false);
    }

    /**
     * Convert a begin-tag to String. Suitable for dumping while parsing.
     * @param reader a reader pointing to a begin-tag.
     * @param addNamespaceDeclarations if true, namespaces are declared.
     * @return the begin-tag as text.
     */
    @QAInfo(level = QAInfo.Level.FINE,
            state = QAInfo.State.QA_NEEDED,
            author = "te",
            comment = "Test expansion of non-default namespaces")
    protected String beginTagToString(
            XMLStreamReader reader, boolean addNamespaceDeclarations) {
        StringWriter tag = new StringWriter(50);
        tag.append("<").append(reader.getLocalName());
        if (addNamespaceDeclarations) {
            addNamespaceDeclarations(reader, tag);
        }
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            addAttribute(tag, reader.getAttributeLocalName(i), reader.getAttributeValue(i));
        }
        tag.append(">");
        return tag.toString();
    }

    /**
     * Adds namespace declarations to the given writer, prepending each
     * declaration with a space.
     * </p><p>
     * Example: {@code ' xmlns="http://www.loc.gov/MARC21/slim"'}. 
     * @param reader where to get the namespace declarations.
     * @param writer the writer to append to.
     */
    private void addNamespaceDeclarations(
            XMLStreamReader reader, StringWriter writer) {
        if (reader.getNamespaceURI() != null) {
            writer.append(" xmlns=\"").append(reader.getNamespaceURI());
            writer.append("\"");
        }
        for (int i = 0 ; i < reader.getNamespaceCount() ; i++) {
            writer.append(" xmlns:");
            writer.append(reader.getNamespacePrefix(i));
            writer.append("=\"").append(reader.getNamespaceURI(i));
            writer.append("\"");
        }
    }

    /**
     * Adds the given attribute to a StringWriter, prepending with space.
     * Example: {@code ' foo="bar&amp;zoo"'}.
     * </p><p>
     * Suitable for overrides if special processing should take place.
     * @param writer    the writer to append to.
     * @param localName the SAX-derived attribute local name.
     * @param value the value of the attribute.
     */
    protected void addAttribute(StringWriter writer, String localName, String value) {
        writer.append(" ").append(localName).append("=\"").append(XMLUtil.encode(value)).append("\"");
    }

    /**
     * Convert an end-tag to String. Suitable for dumping while parsing.
     * @param reader a reader pointing to an end-tag.
     * @return the end-tag as text.
     */
    protected String endTagToString(XMLStreamReader reader) {
        return "</" + reader.getLocalName() + ">";
    }

    /**
     * Expands an id with{@link #id_prefix} and {@link #id_postfix} if they are
     * specified. This should be used before adding any id (including those of
     * parent/child relations) to a Record.
     * @param id the ID to expand.
     * @return the ID expanded with id_prefix and id_postfix.
     */
    protected String expandID(String id) {
        return id_prefix + id + id_postfix;
    }

    @Override
    public String toString() {
        return "MARCParser(base='" + base + "', idPrefix='" + id_prefix + "', idPostfix='" + id_postfix
               + "' (" + super.toString() + "))";
    }
}
