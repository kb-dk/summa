/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package dk.statsbiblioteket.summa.common.util;

import dk.statsbiblioteket.summa.common.Record;
import dk.statsbiblioteket.summa.common.filter.Payload;
import dk.statsbiblioteket.util.Streams;
import dk.statsbiblioteket.util.Strings;
import dk.statsbiblioteket.util.qa.QAInfo;
import dk.statsbiblioteket.util.xml.XMLUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.stream.*;
import javax.xml.stream.events.XMLEvent;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Helpers for processing Records. utf-8 is implicit assumed for Streams and
 * Record content.
 */
@QAInfo(level = QAInfo.Level.NORMAL,
        state = QAInfo.State.QA_NEEDED,
        author = "te")
public class RecordUtil {
    private static Log log = LogFactory.getLog(RecordUtil.class);

    public static final String RECORD_NAMESPACE = "http://statsbiblioteket.dk/summa/2009/Record";

    /**
     * If true, XML generated by {@link #toXML} makes no assumptions about the
     * content of the Records being XML and entity-escaped it all. If false,
     * Record content is assumed to be valid XML, XML-declarations are removed
     * and the XML inserted verbatim.
     * </p><p>
     * As RecordUtil is a utility-class, it does not have an explicit setup.
     * As such, this configuration-property is expected to be used by callers
     * of the {@link #toXML}-method.
     * </p><p>
     * Optional. Default is true.
     */
    public static final String CONF_ESCAPE_CONTENT = "summa.common.recordutil.escapecontent";
    public static final boolean DEFAULT_ESCAPE_CONTENT = true;


    private static XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newInstance();
    private static XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();

    static {
        xmlInputFactory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);
        xmlInputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.TRUE);
        // This important! If we don't do this and parse w3c-xhtml, it will
        // continue to timeout for nearly every invocation
        xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);
    }

    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    private static final String RECORD = "record";

    private static final String ID = "id";
    private static final String BASE = "base";

    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    private static final String DELETED = "deleted";
    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    private static final String INDEXABLE = "indexable";
    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    private static final String CTIME = "ctime";
    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    private static final String MTIME = "mtime";
    private static final String CONTENT = "content";

    private static final String PARENTS = "parents";
    private static final String CHILDREN = "children";

    private static final String META = "meta";
    private static final String ELEMENT = "element";
    private static final String KEY = "key";
    private static final String CONTENT_TYPE = "type";
    private static final String CONTENT_TYPE_XML = "xml";
    private static final String CONTENT_TYPE_STRING = "string";

    /**
     * Represents the given Record as XML, dumping all data in
     * Record.xsd-format. This includes traversing parents and children.
     * While the XML conforms to the xsd, there is no header (aka declaration)
     * as it is expected that the XML will be further wrapped. To include a
     * header, prepend "<?xml version=\"1.0\" encoding=\"UTF-8\"?>.".
     * </p><p>
     * The content of the Record is expected to be an UTF-8 String, which will
     * be entity-escaped. Thus there is no requirements for the content being
     * proper XML.
     * @param record the Record to represent as XML.
     * @return the Record as UTF-8 XML, without header.
     * @throws IOException if an error occured during
     *         XML creation op input record.
     * @see #fromXML(String).
     */
    public static String toXML(Record record) throws IOException {
        return toXML(record, DEFAULT_ESCAPE_CONTENT);
    }

    /**
     * Represents the given Record as XML, dumping all data in
     * Record.xsd-format. This includes traversing parents and children.
     * While the XML conforms to the xsd, there is no header (aka declaration)
     * as it is expected that the XML will be further wrapped. To include a
     * header, prepend "<?xml version=\"1.0\" encoding=\"UTF-8\"?>".
     * </p><p>
     * If escapeContent is true, the content of the Record is expected to be an
     * UTF-8 String, which will be entity-escaped. Thus there is no requirements
     * for the content being proper XML.
     * </p><p>
     * If escapeContent is false, the content is expected to be proper XML and
     * will not be entity-escaped. XML-declarations in the content from the
     * Records will be removed.
     * @param record the Record to represent as XML.
     * @param escapeContent if true, XML-content from the Records will be
     *                      entity-escaped.
     * @return the Record as UTF-8 XML, without header.
     * @throws IOException if an error occured during
     *         XML creation of input record.
     * @see #fromXML
     * @see RecordUtil#toXML(dk.statsbiblioteket.summa.common.Record, boolean)
     * @see RecordUtil#toXML(dk.statsbiblioteket.summa.common.Record)
     * @see RecordUtil#toXML(javax.xml.stream.XMLStreamWriter, int, dk.statsbiblioteket.summa.common.Record, boolean)
     * @see RecordUtil#toXML(javax.xml.stream.XMLStreamWriter, int, java.util.Set, dk.statsbiblioteket.summa.common.Record, boolean)  
     */
    public static String toXML(Record record, boolean escapeContent) throws IOException {
        return toXML(record, escapeContent, null);
    }
    public static String toXML(Record record, boolean escapeContent, String timing) throws IOException {
        log.trace("Creating XML for Record '" + record.getId() + "'");
        long totalTime = -System.currentTimeMillis();
        StringWriter sw = new StringWriter(5000);
        try {
            XMLStreamWriter xmlOut = xmlOutputFactory.createXMLStreamWriter(sw);
            xmlOut.setDefaultNamespace(RECORD_NAMESPACE);
            toXML(xmlOut, 0, new HashSet<Record>(10), record, escapeContent, timing);
        } catch (XMLStreamException e) {
            String error = "Uable to convert record to XML due to XML Stream Exception ";
            log.warn(error);
            throw new IOException(error, e);
        }
        totalTime += System.currentTimeMillis();
        log.debug("Created an XML representation of '" + record.getId() + "' in " + totalTime + " ms");
        return sw.toString();
    }

    /**
     * Take an XMLStreamWriter where the XML describing the given records is
     * added.
     *
     * @param out The XML writer.
     * @param record The record to XMLify.
     * @param level The level of children we should go into.
     * @param escapeContent True if content of records should be escaped, false
     * otherwise.
     * @throws IOException if XMLStreamWriter experience an error.
     */
    public static void toXML(XMLStreamWriter out, int level, Record record, boolean escapeContent) throws IOException {
        try {
            toXML(out, level, new HashSet<Record>(10), record, escapeContent);
        } catch(XMLStreamException e) {
            throw new IOException("Error while creating XML for record '" + record.getId() + "'.", e);
        }
    }

    // http://www.w3.org/TR/xmlschema-2/#dateTime
    // 2002-10-10T17:00:00.000
    private static final SimpleDateFormat schemaTimestampFormatter =
            new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.S");

    /**
     * Take a record an transform it into XMl.
     *
     * @param out the output XML stream.
     * @param level Level of indention.
     * @param processed Set of already processed records.
     * @param record the record to transform into XML.
     * @param escapeContent true if content should be escaped. False otherwise.
     * @throws XMLStreamException if error occur while used XML stream to create
     * XML result.
     */
    @QAInfo(level = QAInfo.Level.FINE,
            state = QAInfo.State.QA_NEEDED,
            comment = "We traverse the tree and ignore already dumped records, "
                     + "but the order is just pulled from thin air")
    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    private static void toXML(XMLStreamWriter out, int level, Set<Record> processed,
                              Record record, boolean escapeContent) throws XMLStreamException {
        toXML(out, level, processed, record, escapeContent, null);
    }

    // TODO: This is a fairly heavy process. See if it can be optimized
    private static void toXML(XMLStreamWriter out, int level, Set<Record> processed, Record record,
                              boolean escapeContent, String timing) throws XMLStreamException {
        if (processed.contains(record)) {
            return;
        }
        processed.add(record);
        log.trace("Constructing inner XML for Record '" + record.getId() + "'");
        String indent = "";
        while (indent.length() < level * 2) {
            indent += "  ";
        }
        if (level != 0) {
            out.writeCharacters("\n");
        }
        out.writeStartElement(RECORD);
        if (level == 0) {
            out.writeNamespace("", RECORD_NAMESPACE);
            if (timing != null && !"".equals(timing)) {
                out.writeAttribute("timing", timing);
            }
        }
        out.writeAttribute(ID, record.getId());
        out.writeAttribute(BASE, record.getBase());
        out.writeAttribute(DELETED, Boolean.toString(record.isDeleted()));
        out.writeAttribute(INDEXABLE, Boolean.toString(record.isIndexable()));
        // FIXME: Point of congestion as all threads synchronize on the static schemaTimestampFormatter
        synchronized (schemaTimestampFormatter) {
            out.writeAttribute(CTIME, schemaTimestampFormatter.format(new Date(record.getCreationTime())));
            out.writeAttribute(MTIME, schemaTimestampFormatter.format(new Date(record.getModificationTime())));
        }
        out.writeCharacters("\n");

        out.writeStartElement(CONTENT);
        try {
            writeContent(out, record, escapeContent);
        } catch (RuntimeException e) {
            throw new XMLStreamException(String.format(Locale.ROOT, "Unable to write XML for content from %s", record), e);
        }
        out.writeEndElement();

        if (record.getParents() != null && !record.getParents().isEmpty()) {
            out.writeCharacters("\n");
            out.writeStartElement(PARENTS);
            for (Record parent: record.getParents()) {
                toXML(out, level+1, processed, parent, escapeContent);
            }
            out.writeCharacters("\n");
            out.writeEndElement();
        }

        if (record.getChildren() != null && !record.getChildren().isEmpty()) {
            out.writeCharacters("\n");
            out.writeStartElement(CHILDREN);
            for (Record child: record.getChildren()) {
                if (log.isTraceEnabled()) {
                    log.trace("Calling toXML on " + child);
                }
                toXML(out, level+1, processed, child, escapeContent);
            }
            out.writeCharacters("\n");
            out.writeEndElement();
        }

        if (record.hasMeta()) {
            out.writeCharacters("\n");
            out.writeStartElement(META);
            for (Map.Entry<String, String> entry: record.getMeta().entrySet()) {
                out.writeCharacters("\n");
                out.writeStartElement(ELEMENT);
                out.writeAttribute(KEY, entry.getKey());
                out.writeCharacters(entry.getValue());
                out.writeEndElement();
            }
            out.writeCharacters("\n");
            out.writeEndElement();
        }

        out.writeCharacters("\n");
        out.writeEndElement(); // record
        out.flush();
    }

    /*
     * The underlying Writer-hack is necessary to write XML directly.
     */
    private static void writeContent(
            XMLStreamWriter out, Record record, boolean escapeContent) throws XMLStreamException {
        if (escapeContent) {
            out.writeCharacters(record.getContentAsUTF8());
            return;
        }
        out.writeAttribute(CONTENT_TYPE, CONTENT_TYPE_XML);
        XMLStreamReader content = xmlInputFactory.createXMLStreamReader(new StringReader(record.getContentAsUTF8()));
        int eventType = content.getEventType();
        if (eventType != XMLEvent.START_DOCUMENT || !content.hasNext()) {
            String snippet = record.getContent() == null ? "[no content in record]" : record.getContentAsUTF8();
            snippet = snippet.substring(0, Math.min(20, snippet.length()));
            throw new XMLStreamException(String.format(Locale.ROOT,
                    "First event was not START_DOCUMENT for '%s...' from %s",
                    snippet, record));
        }
        content.next();
        copyContent(content, out, record, true, -1);
    }

    /**
     * Strips the XML-declaration, if present, from the given XML. This makes it
     * possible to include the XML directly inside another XML structure.
     * @param xml the XML which should have the declaration removed.
     * @return the XML without XML-declaration.
     */
    public static String removeDeclaration(String xml) {
        int start = xml.indexOf("<?xml");
        int end = xml.indexOf('>');
        if (start == -1 || start > 8 || end < start) {
            // At the beginning, compensating for BOM
            return xml;
        }
        return xml.substring(end + 1);
    }

    /**
     * Parses the given XML and creates a Record from it, if possible.
     * @param xml an XML-representation of a Record.
     * @return a Record parsed from the XML.
     * @see #toXML(dk.statsbiblioteket.summa.common.Record)
     * @see #toXML(dk.statsbiblioteket.summa.common.Record, boolean)
     * @see #toXML(javax.xml.stream.XMLStreamWriter, int, dk.statsbiblioteket.summa.common.Record, boolean)
     * @see #toXML(javax.xml.stream.XMLStreamWriter, int, java.util.Set, dk.statsbiblioteket.summa.common.Record, boolean)  
     * @throws IllegalArgumentException if the XML could not be parsed properly.
     */
    public static Record fromXML(String xml) throws IllegalArgumentException {
        return fromXML(new StringReader(xml));
    }

    /**
     * Parses the given XML and creates a Record from it, if possible.
     * This implementation is thread-safe and not synchronized.
     * @param xml an XML-representation of a Record, in UTF-8.
     * @return a Record parsed from the XML.
     * @see #toXML(dk.statsbiblioteket.summa.common.Record)
     * @see #toXML(dk.statsbiblioteket.summa.common.Record, boolean)
     * @see #toXML(javax.xml.stream.XMLStreamWriter, int, dk.statsbiblioteket.summa.common.Record, boolean)
     * @see #toXML(javax.xml.stream.XMLStreamWriter, int, java.util.Set, dk.statsbiblioteket.summa.common.Record, boolean)  
     * @throws IllegalArgumentException if the XML could not be parsed properly.
     */
    public static Record fromXML(Reader xml) throws IllegalArgumentException {
        XMLStreamReader reader;
        try {
            reader = xmlInputFactory.createXMLStreamReader(xml);
        } catch (XMLStreamException e) {
            throw new IllegalArgumentException("Unable to make an XMLStream from the given stream", e);
        }
        try {
            processHeader(reader);
            Record record = processRecord(reader);
            log.debug("Constructed Record '" + record.getId() + "' from XML");
            return record;
        } catch (ParseException e) {
            throw new IllegalArgumentException("Unable to parse XMLStream", e);
        } catch (XMLStreamException e) {
            throw new IllegalArgumentException("Unable to extract content from XMLStream", e);
        }
    }

    private static void processHeader(XMLStreamReader reader)
                                     throws ParseException, XMLStreamException {
        int eventType = reader.getEventType();
        if (eventType != XMLEvent.START_DOCUMENT) {
            //noinspection DuplicateStringLiteralInspection
            throw new ParseException(String.format(Locale.ROOT,
                    "The first event should be start, but it was %s",
                    XMLUtil.eventID2String(eventType)), 0);
        }
        reader.next();
        if (!reader.hasNext()) {
            throw new ParseException("The stream must have a element", 0);
        }
    }

    private static final byte[] DUMMY_CONTENT = new byte[0];
    // Expects the reader to be positioned at record start
    private static Record processRecord(XMLStreamReader reader) throws ParseException, XMLStreamException {
        int eventType = reader.getEventType();
        if (!(eventType == XMLEvent.START_ELEMENT
            && RECORD.equals(reader.getLocalName())
            && RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI()))) {
            throw new ParseException(String.format(Locale.ROOT,
                    "The element should be %s:%s, but was %s:%s",
                    RECORD_NAMESPACE, RECORD,
                    reader.getName().getNamespaceURI(), reader.getLocalName()),
                    reader.getLocation().getCharacterOffset());
        }

        Record record;
        long mtime;
        try {
            //noinspection DuplicateStringLiteralInspection
            String id = getAttributeValue(reader, RECORD_NAMESPACE, ID);
            String base = getAttributeValue(reader, RECORD_NAMESPACE, BASE);
            boolean deleted = Boolean.parseBoolean(getAttributeValue(reader, RECORD_NAMESPACE, DELETED));
            boolean indexable = Boolean.parseBoolean(getAttributeValue(reader, RECORD_NAMESPACE, INDEXABLE));
            long ctime = getDatetimeValue(reader, RECORD_NAMESPACE, CTIME);
            mtime = getDatetimeValue(reader, RECORD_NAMESPACE, MTIME);
            log.trace("Extracted record attributes for Record '" + id + "'");
            record = new Record(id, base, DUMMY_CONTENT);
            record.setDeleted(deleted);
            record.setIndexable(indexable);
            record.setCreationTime(ctime);
        } catch (Exception e) {
            throw new XMLStreamException("Exception extracting attributes", e);
        }

        log.trace("Looking for content, parents, children and meta for Record '" + record.getId() + "'");
        while (reader.hasNext()) {
            reader.next();
            if (reader.getEventType() == XMLStreamReader.END_ELEMENT
                && RECORD.equals(reader.getLocalName())
                && RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                break;
            }
            if (reader.getEventType() != XMLStreamReader.START_ELEMENT) {
                if (reader.getEventType() == XMLStreamReader.CHARACTERS
                    || reader.getEventType() == XMLStreamReader.COMMENT
                    || reader.getEventType() == XMLStreamReader.SPACE) {
                    // Ignore text and comments in between fields
                } else {
                    log.debug("Expected start-elementor chars but got " + XMLUtil.eventID2String(
                            reader.getEventType()) + " in " + record.getId());
                }
                continue;
            }

            if (reader.getEventType() != XMLStreamReader.START_ELEMENT) {
                log.debug(String.format(Locale.ROOT,
                        "processRecord: Expected START_ELEMENT but got %s",
                        XMLUtil.eventID2String(reader.getEventType())));
                continue;
            }

            if (CONTENT.equals(reader.getLocalName()) &&
                RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                log.trace("Found content for Record '" + record.getId() + "'");
                try {
                    record.setContent(getContent(reader, record), false);
                } catch (UnsupportedEncodingException e) {
                    //noinspection DuplicateStringLiteralInspection
                    throw new IllegalStateException("utf-8 not supported", e);
                }
                continue;
            }

            if (PARENTS.equals(reader.getLocalName()) &&
                RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                log.trace("Found parent element for Record '" + record.getId() + "'");
                record.setParents(getRelatives(reader, PARENTS));
                continue;
            }

            if (CHILDREN.equals(reader.getLocalName()) &&
                RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                log.trace("Found children element for Record '" + record.getId() + "'");
                record.setChildren(getRelatives(reader, CHILDREN));
                continue;
            }

            if (META.equals(reader.getLocalName()) &&
                RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                log.trace("Found meta element for Record '" + record.getId() + "'");
                record.setMeta(getMeta(reader));
                continue;
            }

            log.debug("Encountered unexpected start element "
                      + reader.getName().getNamespaceURI() + ":"
                      + reader.getLocalName());
        }
        log.debug("Closing creation of Record '" + record.getId() + "'");
        record.setModificationTime(mtime);
        return record;
    }

    private static byte[] getContent(XMLStreamReader reader, Record record)
                       throws XMLStreamException, UnsupportedEncodingException {
        log.info(XMLUtil.eventID2String(reader.getEventType()));
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            if (reader.getAttributeLocalName(i).equals(CONTENT_TYPE)) {
                String type = reader.getAttributeValue(i);
                if (type.equals(CONTENT_TYPE_XML)) {
                    StringWriter sw = new StringWriter(5000);
                    XMLStreamWriter writer = xmlOutputFactory.createXMLStreamWriter(sw);
                    reader.next();
                    writer.writeStartDocument("UTF-8", "1.0");
                    copyContent(reader, writer, record, true, -1);
                    writer.writeEndDocument();
                    return sw.toString().getBytes(StandardCharsets.UTF_8);
                } else if (!type.equals(CONTENT_TYPE_STRING)) {
                    log.warn(String.format(Locale.ROOT,
                            "Encountered unknown content type '%s' for %s. Parsing as string", type, record));
                }
            }
        }
        return reader.getElementText().getBytes(StandardCharsets.UTF_8);
    }

    /**
     * Copies the content of the current sub-part from reader to writer.
     * By current sub-part we mean everything at the current level and down
     * in the DOM. Copying is stopped as soon as an end-tag above the current
     * level is encountered. The reader is returned positioned at this end tag.
     * @param reader the source.
     * @param writer the destination.
     * @param skipDeclarations if true, declarations, DTDs and notations are not
     *                         copied.
     * @param maxElements the maximum number of elements to copy. Only top-level
     *                    elements are counted. -1 means all elements.
     * @throws IllegalArgumentException if the reader could not
     *         parse its content.
     */
    public static void copyContent(XMLStreamReader reader, XMLStreamWriter writer, boolean skipDeclarations,
                                   int maxElements) throws IllegalArgumentException {
        try {
            copyContent(reader, writer, null, skipDeclarations, maxElements);
        } catch (XMLStreamException e) {
            final String err = "Parsing of reading resulted in a stream exception.";
            log.warn(err);
            throw new IllegalArgumentException(err, e);
        }
    }

    /* Like above but with nice debug message on error is record != null */
    private static void copyContent(XMLStreamReader reader, XMLStreamWriter writer, Record record,
                                    boolean skipDeclarations, int maxElements) throws XMLStreamException {
        int depth = 0;
        int elementcount = 0;
        while (reader.getEventType() != XMLStreamReader.END_DOCUMENT) {
            switch (reader.getEventType()) {
                case XMLStreamReader.END_ELEMENT: {
                    depth--;
                    if (depth < 0) {
                        return; // Too far up
                    }
                    writer.writeEndElement();
                    break;
                }
                case XMLStreamReader.CHARACTERS:
                case XMLStreamReader.SPACE: {
                    writer.writeCharacters(reader.getText());
                    break;
                }
                case XMLStreamReader.CDATA: {
                    writer.writeCData(reader.getText());
                    break;
                }
                case XMLStreamReader.COMMENT: {
                    writer.writeComment(reader.getText());
                    break;
                }
                case XMLStreamReader.PROCESSING_INSTRUCTION: {
                    writer.writeProcessingInstruction(reader.getPITarget(), reader.getPIData());
                    break;
                }
                case XMLStreamReader.ENTITY_REFERENCE: {
                    // TODO: Verify that this part is correct
                    writer.writeEntityRef(reader.getLocalName());
                    break;
                }
                case XMLStreamReader.DTD: {
                    if (!skipDeclarations) {
                        writer.writeDTD(reader.getText());
                    }
                    break;
                }
                case XMLStreamReader.START_DOCUMENT: {
                    if (!skipDeclarations) {
                        // TODO: Don't we need to transfer more information?
                        writer.writeStartDocument(reader.getVersion());
                    }
                    break;
                }
                case XMLStreamReader.NAMESPACE: {
                    for (int i = 0 ; i < reader.getNamespaceCount() ; i++) {
                        writer.writeNamespace(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
                    }
                    break;
                }
                case XMLStreamReader.START_ELEMENT: {
                    if (elementcount == maxElements) {
                        return;
                    }
                    elementcount++;
                    String namespaceURI = reader.getNamespaceURI();
                    if (namespaceURI != null) {
                        writer.writeStartElement( reader.getPrefix(), reader.getLocalName(), reader.getNamespaceURI());
                    } else {
                        writer.writeStartElement(reader.getLocalName());
                    }
                    // TODO: What about default namespace?
                    for (int i = 0 ; i < reader.getNamespaceCount() ; i++) {
                        writer.writeNamespace(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
                    }
                    for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
                        if (reader.getAttributeNamespace(i) == null) {
                            writer.writeAttribute(reader.getAttributeLocalName(i), reader.getAttributeValue(i));
                            continue;
                        }
                        writer.writeAttribute(reader.getAttributePrefix(i), reader.getAttributeNamespace(i),
                                              reader.getAttributeLocalName(i), reader.getAttributeValue(i));
                    }
                    depth++;
                    break;
                }
                default: {
                    throw new XMLStreamException(String.format(Locale.ROOT,
                            "Unknown event type %d from reader", reader.getEventType()));
                }
            }
            try {
                reader.next();
            } catch (XMLStreamException e) {
                if (record == null) {
                    throw new XMLStreamException("Parse error (content could not be extracted for debugging)",
                                                 e.getLocation(), e);
                }
                String content = record.getContent() == null ? "[no content]" : record.getContentAsUTF8();
                throw new XMLStreamException(String.format(Locale.ROOT,
                        "Parse error. First 20 characters of %s was '%s'. Error was '%s'",
                        record, content.substring(0, Math.min(20, content.length())),
                        e.getMessage()), e.getLocation(), e);
            }
        }
    }

    private static List<Record> getRelatives(XMLStreamReader reader, String relative) throws XMLStreamException {
        List<Record> relatives = new ArrayList<>(5);
        while (reader.hasNext()) {
            reader.next();
            if (reader.getEventType() == XMLStreamReader.END_ELEMENT && relative.equals(reader.getLocalName())
                && RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                break;
            }
            if (reader.getEventType() == XMLStreamReader.START_ELEMENT) {
                try {
                    relatives.add(processRecord(reader));
                } catch (Exception e) {
                    log.warn("Unable to expand relative Record of type " + relative, e);
                }
                continue;
            }
            //noinspection DuplicateStringLiteralInspection
            log.trace("Skipping event " + XMLUtil.eventID2String(reader.getEventType())
                      + " in getRelatives(..., " + relative + ")");
        }
        //noinspection DuplicateStringLiteralInspection
        log.trace("Expanded " + relatives.size() + " relatives of type " + relative);
        return relatives;

    }

    private static StringMap getMeta(XMLStreamReader reader) throws XMLStreamException {
        StringMap map = new StringMap(10);
        while (reader.hasNext()) {
            reader.next();
            if (reader.getEventType() == XMLStreamReader.END_ELEMENT && META.equals(reader.getLocalName())
                && RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                break;
            }
            if (reader.getEventType() == XMLStreamReader.START_ELEMENT && ELEMENT.equals(reader.getLocalName())
                    && RECORD_NAMESPACE.equals(reader.getName().getNamespaceURI())) {
                log.trace("Entered meta element");
                map.put(getAttributeValue(reader, KEY, RECORD_NAMESPACE), reader.getElementText());
                continue;
            }
            //noinspection DuplicateStringLiteralInspection
            log.trace("Skipping event " + XMLUtil.eventID2String(reader.getEventType()) + " in getMeta");
        }
        //noinspection DuplicateStringLiteralInspection
        log.trace("Expanded " + map.size() + " meta elements");
        return map;
    }

    private static long getDatetimeValue(
            XMLStreamReader reader, String namespace, String attribute) throws ParseException {
        String sVal = getAttributeValue(reader, namespace, attribute);
        return schemaTimestampFormatter.parse(sVal).getTime();
    }

    // TODO: Make this namespace aware, sync with StreamingdocumentCreator then
    @SuppressWarnings({"UnusedDeclaration"})
    private static String getAttributeValue(XMLStreamReader reader, String namespace, String localName) {
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            if (localName.equals(reader.getAttributeLocalName(i))) {
                return reader.getAttributeValue(i);
            }
        }
        return null;
    }

    /**
     * Calculates the approximate memory usage of the Record.
     * </p><p>
     * This method is fairly light-weight and aims for approximations in the
     * kilobyte range. Thus the length of String attributes et al are ignored.
     * The sizes is primarily determined by content and meta-data.
     * @param record      the Record to calculate memory usage for.
     * @param followLinks if true, a transitive traversal of parents and
     *                    children is performed, summing the sizes.
     * @return the approximate memory usage of the Record.
     */
    public static int calculateRecordSize(Record record, boolean followLinks) {
        return calculateRecordSize(record, followLinks, null);
    }

    private static int calculateRecordSize(Record record, boolean followLinks, Set<Record> visited) {
        if (visited != null) {
            if (visited.contains(record)) {
                return 0;
            }
            visited.add(record);
        }

        int size = record.getContent(false) == null ? 0
                   : record.getContent(false).length;
        if (record.getMeta() != null) {
            for (Map.Entry<String, String> entry: record.getMeta().entrySet()) {
                try {
                    size += entry.getKey().length() + entry.getValue().length();
                } catch (NullPointerException e) {
                    log.trace("NPE while requesting key and value size from entry " + entry.getKey() + " in " + record,
                              e);
                }
            }
        }
        if (!followLinks || record.getParents() == null && record.getChildren() == null) {
            return size;
        }
        if (visited == null) {
            visited = new HashSet<>(10);
            visited.add(record);
        }
        if (record.getParents() != null) {
            for (Record parent: record.getParents()) {
                size += calculateRecordSize(parent, followLinks, visited);
            }
        }
        if (record.getChildren() != null) {
            for (Record child: record.getChildren()) {
                size += calculateRecordSize(child, followLinks, visited);
            }
        }
        return size;
    }

    public static Pattern safePattern = Pattern.compile("[a-zA-Z0-9\\-\\_\\.]");
    public static int counter = 0;

    /**
     * Use the Payload ID to generate a safe file name.
     * @param payload the base for the file name.
     * @return a conservative file name.
     */
    public static String getFileName(Payload payload) {
        String candidate = payload.getId();
        return getFileName(candidate);
    }

    public static String getFileName(String candidate) {
        if (candidate == null || "".equals(candidate)) {
            Calendar calendar = Calendar.getInstance();
            return String.format(Locale.ROOT, "%1$tF_%1$tH%1$tM%1$tS_", calendar) + Integer.toString(counter++);
        }
        StringWriter fn = new StringWriter(candidate.length());
        for (char c: candidate.toCharArray()) {
            if (safePattern.matcher("" + c).matches()) {
                fn.append(c);
            } else {
                fn.append("_");
            }
        }
        String actual = fn.toString();
        log.trace("Transformed the name '" + candidate + "' into '" + actual + "'");
        return actual;
    }

    public static enum PART {id, base, content, xmlfull, childid, parentid, meta;

        @Override
        public String toString() {
            return this == meta ? "meta." : super.toString();
        }
    }
/*    public static final String PART_ID = "id";
    public static final String PART_BASE = "base";
    public static final String PART_CONTENT = "content";
    public static final String PART_XML_FULL = "xmlfull";
    public static final String PART_CHILDID = "childid";
    public static final String PART_PARENTID = "parentid";
    public static final String PART_META_PREFIX = "meta.";*/

    /**
     * Return a String from a Record's content, id, base of meta-field.
     * @param record the String provider.
     * @param source where to extract the String from. Valid values are 'id',
     *        'base', 'content' and 'meta.key' where the key in meta.key is
     *        used to get a meta-value.
     * @return a String extracted from the Record.
     */
    public static String getString(Record record, String source) {
        if (source.startsWith(PART.meta.toString())) {
            String key = source.substring(PART.meta.toString().length(), source.length());
            String content = record.getMeta(key);
            if (content == null) {
                throw new IllegalArgumentException("No value for key '" + key + "' in " + record);
            }
            return content;
        }
        return getString(record, PART.valueOf(source));
    }

    /**
     * Return a String from a Record. Note that this does not allow the use of {@link PART#meta}.
     * @param record the String provider.
     * @param source where to extract the String from.
     * @return a String extracted from the Record.
     */
    public static String getString(Record record, PART source) {
        switch (source) {
            case id:       return record.getId();
            case base:     return record.getBase();
            case content:  return record.getContentAsUTF8();
            case xmlfull:
                try {
                    return toXML(record);
                } catch (IOException e) {
                    throw new IllegalArgumentException("Unable to represent record " + record + " as XML", e);
                }
            case childid:  return record.getChildIds() == null  ? null: Strings.join(record.getChildIds());
            case parentid: return record.getParentIds() == null ? null: Strings.join(record.getParentIds());
            case meta: throw new UnsupportedOperationException("The part " + PART.meta + " cannot be used directly");
            default: throw new IllegalArgumentException("Unknown source '" + source + "'");
        }
    }

    /**
     * Wrapper for {@link #getString(Record, String)}. If the Payload
     * encapsulates a Stream, the Stream is returned regardless of source.
     * If not, the Record-based getString is called.
     * </p><p>
     * Warning: When the Payload is Stream-based, resolving to an in-memory
     * String might require a lot of memory.
     * @param payload the source of the String if the Payload does not contain
     *        a Stream.
     * @param source where to extract the String from if the Payload does not
     *        contain a Stream.
     * @return a String extracted from the Payload.
     */
    public static String getString(Payload payload, String source) {
        if (payload.getStream() == null) {
            return getString(payload.getRecord(), source);
        }
        try {
            return Strings.flush(payload.getStream());
        } catch (IOException e) {
            throw new RuntimeException("Unable to flush the Stream in " + payload, e);
        }
    }

    /**
     * Wrapper for {@link #getString(Record, String)}. If the Payload
     * encapsulates a Stream, the Stream is returned regardless of source.
     * If not, the Record-based getString is called.
     * </p><p>
     * Warning: When the Payload is Stream-based, resolving to an in-memory
     * String might require a lot of memory.
     * @param payload the source of the String if the Payload does not contain
     *        a Stream.
     * @param source where to extract the String from if the Payload does not
     *        contain a Stream.
     * @return a String extracted from the Payload.
     */
    public static String getString(Payload payload, PART source) {
        if (payload.getStream() == null) {
            return getString(payload.getRecord(), source);
        }
        try {
            return Strings.flush(payload.getStream());
        } catch (IOException e) {
            throw new RuntimeException("Unable to flush the Stream in " + payload, e);
        }
    }

    /**
     * Shorthand for getString(payload, "content").
     * @param payload see the JavaDoc for {@link #getString(Payload, String)}.
     * @return see the JavaDoc for {@link #getString(Payload, String)}.
     */
    public static String getString(Payload payload) {
        return getString(payload, PART.content);
    }

    /**
     * If the Payload encapsulates a Stream, the bytes from that stream will be returned. Else the bytes from the
     * Record content will be returned.
     * </p><p>
     * Warning: The byte-array might be shared with the Payload. The caller should not modify it.
     * @param payload the Payload with wanted content.
     * @return a byte array with the content, regardless of Payload type.
     * @throws java.io.IOException if there was an error accessing the stream of the Payload.
     */
    public static byte[] getBytes(Payload payload) throws IOException {
        if (payload.getStream() == null) {
            return payload.getRecord().getContent();
        }
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        Streams.pipe(payload.getStream(), bos);
        return bos.toByteArray();
    }


    /**
     * Return a stream from a Record's content, id, base of meta-field.
     * @param record the stream provider.
     * @param source where to construct the stream. Valid values are 'id',
     *        'base', 'content' and 'meta.key' where the key in meta.key is
     *        used to get a meta-value.
     * @return a stream constructed from the Record.
     */
    public static InputStream getStream(Record record, String source) {
        if (PART.content.toString().equals(source)) {
            return new ByteArrayInputStream(record.getContent());
        }
        return new ReaderInputStream(new StringReader(getString(record, source)), "utf-8");
    }

    /**
     * Wrapper for {@link #getStream(Record, String)}. If the Payload
     * encapsulates a Stream, the Stream is returned regardless of source.
     * If not, the Record-based getStream is called.
     * @param payload the source of the Stream if the Payload does not contain
     *        a Stream.
     * @param source where to construct the Stream from if the Payload does not
     *        contain a Stream.
     * @return a Stream based on the Payload.
     */
    public static InputStream getStream(Payload payload, String source) {
        if (payload.getStream() == null) {
            return getStream(payload.getRecord(), source);
        }
        return payload.getStream();
    }

    /**
     * Shorthand for getStream(payload, "content").
     * @param payload see the JavaDoc for {@link #getStream(Payload, String)}.
     * @return see the JavaDoc for {@link #getStream(Payload, String)}.
     */
    public static InputStream getStream(Payload payload) {
        return getStream(payload, PART.content.toString());
    }

    /**
     * Return a reader from a Record's content, id, base of meta-field.
     * @param record the reader provider.
     * @param source where to construct the reader. Valid values are 'id',
     *        'base', 'content' and 'meta.key' where the key in meta.key is
     *        used to get a meta-value.
     * @return a reader constructed from the Record.
     */
    public static Reader getReader(Record record, String source) {
        if (PART.content.toString().equals(source)) {
            return new InputStreamReader(new ByteArrayInputStream(record.getContent()), StandardCharsets.UTF_8);
        }
        return new StringReader(getString(record, source));
    }

    public static Reader getReader(Record record, PART source) {
        if (source == PART.content) {
            return new InputStreamReader(new ByteArrayInputStream(record.getContent()), StandardCharsets.UTF_8);
        }
        return new StringReader(getString(record, source));
    }

    /**
     * Wrapper for {@link #getReader(Record, String)}. If the Payload
     * encapsulates a Stream, the Stream is returned regardless of source.
     * If not, the Record-based getReader is called.
     * @param payload the source of the reader if the Payload does not contain
     *        a Stream.
     * @param source where to construct the reader from if the Payload does not
     *        contain a Stream.
     * @return a reader based on the Payload.
     */
    public static Reader getReader(Payload payload, String source) {
        if (payload.getStream() == null) {
            return getReader(payload.getRecord(), source);
        }
        return new InputStreamReader(payload.getStream(), StandardCharsets.UTF_8);
    }

    /**
     * Shorthand for getReader(payload, "content").
     * @param payload see the JavaDoc for {@link #getReader(Payload, String)}.
     * @return see the JavaDoc for {@link #getReader(Payload, String)}.
     */
    public static Reader getReader(Payload payload) {
        return getReader(payload, PART.content.toString());
    }

    /**
     * Assign the given value to the Record's content, id, base of meta-field.
     * @param record the receiver of the value.
     * @param value the value to assign.
     * @param destination for the given value. Valid values are 'id',
     *        'base', 'content' and 'meta.key' where the key in meta.key is
     *        used to get a meta-value. If no known destination is given, the
     *        fallback is to assign the value with the destination used directly
     *        as key.
     */
    public static void setString(Record record, String value, String destination) {
        if (destination.startsWith(PART.meta.toString())) {
            String key = destination.substring(PART.meta.toString().length(), destination.length());
            record.getMeta().put(key, value);
            return;
        }
        try {
            PART part = PART.valueOf(destination);
            switch (part) {
                case id:
                    record.setId(value);
                    break;
                case base:
                    record.setBase(value);
                    break;
                case content:
                    record.setContent(value.getBytes(StandardCharsets.UTF_8), false);
                    break;
                case xmlfull: throw new IllegalArgumentException(
                        "The part " + PART.xmlfull + " is unsupported as setting the full XMLTree does not make sense");
                case childid:
                    if (record.getChildIds() == null) {
                        record.setChildIds(new ArrayList<>(Arrays.asList(value)));
                    } else {
                        record.getChildIds().add(value);
                    }
                    break;
                case parentid:
                    if (record.getParentIds() == null) {
                        record.setParentIds(new ArrayList<>(Arrays.asList(value)));
                    } else {
                        record.getParentIds().add(value);
                    }
                    break;
                case meta: throw new IllegalArgumentException(
                        "The part " + PART.meta.toString() + " can only be used as prefix, not directly");
                default: throw new UnsupportedOperationException("The part " + part + " is unknown");
            }
        } catch (IllegalArgumentException e) {
            record.getMeta().put(destination, value);
        }
    }

    /**
     * Assign the given value to the Record's content, id, base of meta-field.
     * @param record the receiver of the value.
     * @param value the value to assign.
     * @param destination for the given value. Valid values are 'id',
     *        'base', 'content' and 'meta.key' where the key in meta.key is
     *        used to get a meta-value. If no known destination is given, the
     *        fallback is to assign the value with the destination used directly
     *        as key.
     */
    public static void setBytes(Record record, byte[] value, String destination) {
        if (PART.content.toString().equals(destination)) {
            record.setContent(value, false);
        }
        setString(record, new String(value, StandardCharsets.UTF_8), destination);
    }

    /**
     * Returns at most limit characters from the source in the given Record.
     * The implementation creates a temporary Reader and Writer if the source is
     * {@link PART#content}.
     * @param record the String provider.
     * @param source where to extract the String from. Valid values are 'id',
     *        'base', 'content' and 'meta.key' where the key in meta.key is
     *        used to get a meta-value.
     * @param limit the maximum number of characters to return.
     *              0 means no limit ans is equivalent to a plain getString.
     * @return a String extracted from the Record.
     */
    public static String getString(Record record, String source, int limit) {
        if (limit == 0) {
            return getString(record, source);
        }

        if (PART.id.toString().equals(source) || PART.base.toString().equals(source) ||
            source.startsWith(PART.meta.toString())) {
            String full = getString(record, source);
            return full.length() <= limit ? full : full.substring(0, limit);
        }

        Reader reader = RecordUtil.getReader(record, source);
        StringWriter sw = new StringWriter(Math.min(limit, 1000000));
        int count = 0;
        int c;
        try {
            // TODO: Optimize this by using a buffer
            while (count < limit && (c = reader.read()) != -1) {
                sw.append((char)c);
                count++;
            }
        } catch (IOException e) {
            throw new RuntimeException("IOException while flushing reader for " + record + " with source " + source
                                       + " and limit " + limit, e);
        }
        return sw.toString();
    }

    private static final byte[] EMPTY = new byte[0];
    /**
     * Deep copy of the Record. Children and Parents are cloned as well.
     * </p><p>
     * Note: Meta content from {@link dk.statsbiblioteket.summa.common.Record#getMeta()} is only shallow copied.
     * @param record the record to clone.
     * @param referenceContent if true, the content of the Record is shared. If false, it is copied, making the
     *                         newly created Record fully independent of the old.
     * @return an identical copy of record.
     */
    public static Record clone(Record record, boolean referenceContent) {
        Record newRecord = new Record(record.getId(), record.getBase(), EMPTY);
        byte[] rawContent = record.getContent(false);
        newRecord.setRawContent(referenceContent ?
                                        rawContent :
                                        Arrays.copyOf(rawContent, rawContent.length), record.isContentCompressed());
        newRecord.setDeleted(record.isDeleted());
        newRecord.setIndexable(record.isIndexable());
        newRecord.setCreationTime(record.getCreationTime());
        newRecord.setModificationTime(record.getModificationTime());
        newRecord.setHasRelations(record.isHasRelations());
        if (record.getChildIds() != null) {
            newRecord.setChildIds(new ArrayList<>(record.getChildIds()));
        }
        if (record.getChildren() != null) {
            List<Record> newChildren = new ArrayList<>(record.getChildren().size());
            for (Record childRecord: record.getChildren()) {
                newChildren.add(clone(childRecord, referenceContent));
            }
            newRecord.setChildren(newChildren);
        }
        if (record.getParentIds() != null) {
            newRecord.setParentIds(new ArrayList<>(record.getParentIds()));
        }
        if (record.getParents() != null) {
            List<Record> newParents = new ArrayList<>(record.getParents().size());
            for (Record parentRecord: record.getParents()) {
                newParents.add(clone(parentRecord, referenceContent));
            }
            newRecord.setParents(newParents);
        }
        if (record.hasMeta()) {
            for (Map.Entry<String, String> entry: record.getMeta().entrySet()) {
                newRecord.addMeta(entry.getKey(), entry.getValue());
            }
        }
        return newRecord;
    }


    /**
     * If the Payload contains a Stream, it will be copied into memory, the old stream will be closed and a new
     * stream will be created from the copied bytes.
     * </p><p>
     * Used to de-couple the Payload from the source.
     * @param payload a Payload with a stream.
     * @return the payload with the stream de-coupled from the original stream.
     */
    public static Payload copyStream(Payload payload) throws IOException {
        if (payload.getRecord() != null) {
            return payload;
        }
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        Streams.pipe(payload.getStream(), bos);
        payload.setStream(new ByteArrayInputStream(bos.toByteArray()));
        return payload;
    }

    /**
     * If the content of the Record is compressed, it will be uncompressed.
     * @param record the Record with the content to uncompress.
     * @param transitive if true, a transitive graph-traversal will be triggered, uncompressing parents and children.
     * @return true if at least 1 uncompression was performed.
     */
    public static boolean uncompress(Record record, boolean transitive) {
        if (transitive) {
            return adjustCompression(record, null, false);
        }
        return adjustCompression(record, false);
    }

    /**
     * Ensures that the compression of the content for the given Record matches shouldBeCompressed.
     * Also, a transitive graph-traversal will be performed, processing parents and children in the same manner.
     * @param record the Record with the content to uncompress.
     * @param alreadyProcessed IDs for the Records already processed, to guard against cycles.
     *                         If null, a new set will be created.
     * @param shouldBeCompressed the wanted state of the content.
     * @return true if at least 1 compression state adjustment was performed.
     */
    public static boolean adjustCompression(Record record, Set<String> alreadyProcessed, boolean shouldBeCompressed) {
        boolean changed = adjustCompression(record, shouldBeCompressed);
        if (alreadyProcessed == null) {
            alreadyProcessed = new HashSet<>();
        }
        alreadyProcessed.add(record.getId());
        if (record.getParents() != null) {
            for (Record parent : record.getParents()) {
                changed |= adjustCompression(parent, alreadyProcessed, shouldBeCompressed);
            }
        }
        if (record.getChildren() != null) {
            for (Record child : record.getChildren()) {
                changed |= adjustCompression(child, alreadyProcessed, shouldBeCompressed);
            }
        }
        return changed;
    }

    /**
     * Ensures that the compression of the content for the given Record matches shouldBeCompressed.
     * @param record the Record with the content to uncompress.
     * @param shouldBeCompressed the wanted state of the content.
     * @return true if at least 1 compression state adjustment was performed.
     */
    public static boolean adjustCompression(Record record, boolean shouldBeCompressed) {
        boolean changed = true;
        if (shouldBeCompressed && !record.isContentCompressed()) {
            record.setContent(record.getContent(true), true);
        }
        if (!shouldBeCompressed && record.isContentCompressed()) {
            record.setContent(record.getContent(true), false);
        } else {
            changed = false;
        }
        return changed;
    }

    /**
     * Poor man's prettify of non-parsed XML.
     * Takes a String that is expected to be XML and inserts newlines after all end-tags, except the last one.
     * If there are already a newline after an end tag, no new newline is inserted.
     * @param xml needs not be valid as no real parsing is taking place.
     * @return the XML with newlines after end-tags.
     */
    public static String prettifyXML(String xml) {
        return NEWLINER.matcher(xml).replaceAll("$1\n$2");
    }
    private final static Pattern NEWLINER = Pattern.compile("(</[^>]+>)([^\n])", Pattern.DOTALL);

    /**
     * Replaces invalid Unicode characters with ❔ (x2754;).
     * Note: Only hexadecimal representations are checked, so {@code &#5;} will not be filtered although it is invalid.
     * @param xml String-representation of XML.
     * @return the input without invalid Unicodes.
     */
    public static String replaceInvalidUnicode(String xml) {
        return INVALID_UNICODE_RANGE.matcher(xml).replaceAll("&#x2754;");
    }

    // Char	   ::=   	#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
    private static final Pattern INVALID_UNICODE_RANGE = Pattern.compile(
            "(?s)&#x0*(" +
            "[0-8BCEFcef]" + "|" +                 // x0-x8, xB, xE, xF
            "1[0-9A-Fa-f]" + "|" +                 // x10-x1F
            "[Dd][89A-Fa-f][0-9A-Fa-f]{2}" + "|" + // D800-DFFF
            "[Ff]{3}[EeFf]" + "|" +                // FFFE-FFFF
            "1[1-9][0-9A-Fa-f]{4}" +               // 110000-1FFFFF
            ");"
            );
}
